#!/usr/bin/env python3
"""
Convert a folder of per-image LabelMe JSON annotations into a single COCO-style
annotation file that can be paired with a bundled media artifact. When provided
with the frame manifest written by `bundle_images.py`, the script keeps the
annotation order perfectly aligned with the bundled media frames.
"""

from __future__ import annotations

import argparse
import json
import logging
import sys
from pathlib import Path
from typing import Any, Iterable, Optional


SUPPORTED_SHAPES = {"polygon", "rectangle"}


def parse_args(argv: list[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Merge LabelMe JSON annotations into one COCO-style file. The script "
            "derives categories automatically and preserves polygon geometry."
        )
    )
    parser.add_argument(
        "--labels",
        required=True,
        type=Path,
        help="Directory that contains the LabelMe JSON files.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("output/unified_annotation.json"),
        help=(
            "Path to the unified annotation JSON file to write. Defaults to "
            "output/unified_annotation.json."
        ),
    )
    parser.add_argument(
        "--image-root",
        "--images",
        dest="image_root",
        type=Path,
        help=(
            "Optional root directory that contains the image files. When provided, "
            "the script verifies that the referenced image exists."
        ),
    )
    parser.add_argument(
        "--skip-missing-images",
        action="store_true",
        help=(
            "Skip annotations whose image file is missing instead of failing. "
            "Only relevant when --image-root is supplied."
        ),
    )
    parser.add_argument(
        "--manifest",
        type=Path,
        help=(
            "Source of the frame manifest JSON generated by bundle_images.py. "
            "Pass '-' to read the manifest from standard input. When omitted, "
            "alignment is skipped unless --require-manifest is supplied."
        ),
    )
    parser.add_argument(
        "--skip-manifest",
        action="store_true",
        help="Ignore the frame manifest even if it exists.",
    )
    parser.add_argument(
        "--require-manifest",
        action="store_true",
        help="Fail when the manifest is missing or does not cover every label.",
    )
    parser.add_argument(
        "--log-level",
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        help="Set the logging verbosity (default: INFO).",
    )
    return parser.parse_args(argv)


def discover_label_files(root: Path) -> list[Path]:
    if not root.exists() or not root.is_dir():
        raise FileNotFoundError(f"Label directory not found: {root}")
    pattern = "*.json"
    return sorted(path for path in root.glob(pattern) if path.is_file())


def ensure_output_path(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)


def polygon_area(points: Iterable[list[float]]) -> float:
    pts = list(points)
    if len(pts) < 3:
        return 0.0
    area = 0.0
    for idx, (x1, y1) in enumerate(pts):
        x2, y2 = pts[(idx + 1) % len(pts)]
        area += x1 * y2 - x2 * y1
    return abs(area) / 2.0


def to_polygon(points: list[list[float]], shape_type: str) -> list[list[float]]:
    if shape_type == "rectangle" and len(points) == 2:
        (x1, y1), (x2, y2) = points
        return [[x1, y1], [x2, y1], [x2, y2], [x1, y2]]
    return points


def bbox_from_polygon(points: list[list[float]]) -> list[float]:
    xs = [p[0] for p in points]
    ys = [p[1] for p in points]
    min_x = min(xs)
    max_x = max(xs)
    min_y = min(ys)
    max_y = max(ys)
    return [min_x, min_y, max_x - min_x, max_y - min_y]


def flatten_polygon(points: list[list[float]]) -> list[float]:
    return [coord for pair in points for coord in pair]


def load_label_file(path: Path) -> dict[str, Any]:
    with path.open("r", encoding="utf-8") as stream:
        return json.load(stream)


def resolve_image_path(
    image_root: Path | None,
    file_name: str,
    manifest_entry: dict[str, Any] | None = None,
    manifest_root: Path | None = None,
) -> Path | None:
    candidates: list[Path] = []

    base_name = Path(file_name).name
    if image_root is not None:
        candidates.append(image_root / file_name)
        if base_name != file_name:
            candidates.append(image_root / base_name)
        if manifest_entry is not None:
            relative_path = manifest_entry.get("relative_path")
            if relative_path:
                candidates.append(image_root / relative_path)

    if manifest_root is not None and manifest_entry is not None:
        relative_path = manifest_entry.get("relative_path")
        if relative_path:
            candidates.append(manifest_root / relative_path)
        candidates.append(manifest_root / base_name)

    if manifest_root is not None:
        candidates.append(manifest_root / file_name)

    for candidate in candidates:
        try:
            if candidate.exists():
                return candidate
        except OSError:
            continue

    return None


def read_image_dimensions(path: Path | None) -> Optional[tuple[int, int]]:
    if path is None:
        return None

    try:
        from PIL import Image  # type: ignore

        with Image.open(path) as image:  # type: ignore[attr-defined]
            width, height = image.size
            return int(width), int(height)
    except Exception:  # pragma: no cover - optional dependency
        pass

    try:
        import cv2  # type: ignore

        frame = cv2.imread(str(path))
        if frame is not None:
            height, width = frame.shape[:2]
            return int(width), int(height)
    except Exception:  # pragma: no cover - optional dependency
        pass

    return None


def load_frame_manifest(path: Path) -> dict[str, Any]:
    with path.open("r", encoding="utf-8") as stream:
        manifest = json.load(stream)

    if not isinstance(manifest, dict) or "images" not in manifest:
        raise ValueError("Invalid frame manifest format. Missing 'images' list.")
    if not isinstance(manifest["images"], list):
        raise ValueError("Frame manifest 'images' field must be a list.")

    return manifest


def load_frame_manifest_from_string(payload: str) -> dict[str, Any]:
    try:
        manifest = json.loads(payload)
    except json.JSONDecodeError as exc:  # pragma: no cover - malformed input path
        raise ValueError(f"Failed to decode manifest JSON: {exc}") from exc

    if not isinstance(manifest, dict) or "images" not in manifest:
        raise ValueError("Invalid frame manifest format. Missing 'images' list.")
    if not isinstance(manifest["images"], list):
        raise ValueError("Frame manifest 'images' field must be a list.")

    return manifest


def build_annotation_dataset(
    label_files: list[Path],
    image_root: Path | None,
    skip_missing_images: bool,
    frame_manifest: dict[str, Any] | None,
    manifest_path: Path | str | None,
    require_manifest: bool,
) -> dict[str, Any]:
    records: list[dict[str, Any]] = []
    records_by_name: dict[str, list[dict[str, Any]]] = {}

    for label_file in label_files:
        data = load_label_file(label_file)
        file_name = data.get("imagePath") or f"{label_file.stem}.jpg"
        base_name = Path(file_name).name
        width = data.get("imageWidth")
        height = data.get("imageHeight")
        resolved_image = resolve_image_path(image_root, file_name)

        if (width is None or height is None) and resolved_image is not None:
            dims = read_image_dimensions(resolved_image)
            if dims:
                width, height = dims

        if width is None or height is None:
            logging.warning("Missing image dimensions in %s (skipping)", label_file)
            continue

        if image_root is not None and resolved_image is None:
            message = f"Image file not found for annotation {label_file}: {file_name}"
            if skip_missing_images:
                logging.warning(message + " (skipping)")
                continue
            raise FileNotFoundError(message)

        record = {
            "label_file": label_file,
            "data": data,
            "file_name": base_name,
            "source_image_path": file_name,
            "width": width,
            "height": height,
            "frame_index": None,
        }
        records.append(record)
        records_by_name.setdefault(base_name, []).append(record)

    ordered_records = records
    unmatched_manifest_entries: list[str] = []
    unmatched_label_records: list[str] = []
    frames_without_labels: list[str] = []
    bundle_path = None

    if frame_manifest is not None:
        manifest_images = frame_manifest.get("images", [])
        bundle_path = frame_manifest.get("bundle_path")
        manifest_root_str = frame_manifest.get("source_root")
        manifest_root = Path(manifest_root_str) if manifest_root_str else None
        ordered_records = []
        for entry in manifest_images:
            file_name = entry.get("file_name")
            if not file_name:
                continue
            key = Path(file_name).name
            bucket = records_by_name.get(key)
            dims: Optional[tuple[int, int]] = None
            if bucket:
                record = bucket.pop(0)
                record["frame_index"] = entry.get("frame_index")
                record["manifest_entry"] = entry
                if record.get("width") is None or record.get("height") is None:
                    if image_root is not None:
                        resolved = resolve_image_path(image_root, record["source_image_path"], entry, manifest_root)
                    else:
                        resolved = resolve_image_path(None, record["source_image_path"], entry, manifest_root)
                    dims = read_image_dimensions(resolved)
                    if dims:
                        record["width"], record["height"] = dims
                ordered_records.append(record)
            else:
                frames_without_labels.append(key)
                resolved = resolve_image_path(image_root, key, entry, manifest_root)
                dims = read_image_dimensions(resolved)

                record = {
                    "label_file": None,
                    "data": {"shapes": []},
                    "file_name": key,
                    "source_image_path": entry.get("relative_path")
                    or entry.get("file_name")
                    or key,
                    "width": dims[0] if dims else None,
                    "height": dims[1] if dims else None,
                    "frame_index": entry.get("frame_index"),
                    "manifest_entry": entry,
                }
                if record["width"] is None or record["height"] is None:
                    logging.warning(
                        "No label for manifest image %s and dimensions could not be determined",
                        key,
                    )
                    unmatched_manifest_entries.append(key)
                ordered_records.append(record)

        leftover_records: list[dict[str, Any]] = []
        for bucket in records_by_name.values():
            leftover_records.extend(bucket)

        if leftover_records:
            leftover_records.sort(key=lambda rec: rec["file_name"].lower())
            ordered_records.extend(leftover_records)
            unmatched_label_records = [rec["file_name"] for rec in leftover_records]
    else:
        ordered_records = sorted(records, key=lambda rec: rec["file_name"].lower())

    if unmatched_manifest_entries:
        logging.warning(
            "Manifest references images without matching labels: %s",
            ", ".join(sorted(set(unmatched_manifest_entries))),
        )
    if unmatched_label_records:
        logging.warning(
            "Labels without manifest entries will be appended after aligned frames: %s",
            ", ".join(sorted(set(unmatched_label_records))),
        )
    if frames_without_labels:
        logging.info(
            "Frames without matching labels will remain with empty annotations: %s",
            ", ".join(sorted(set(frames_without_labels))),
        )

    if require_manifest:
        if frame_manifest is None:
            raise ValueError("Manifest required but not provided.")
        if unmatched_manifest_entries or unmatched_label_records:
            raise ValueError("Manifest mismatch: see warnings for details.")
        missing_frame_indices = [
            rec["file_name"] for rec in ordered_records if rec.get("frame_index") is None
        ]
        if missing_frame_indices:
            raise ValueError(
                "Manifest missing entries for labels: "
                + ", ".join(sorted(set(missing_frame_indices)))
            )

    dataset: dict[str, Any] = {
        "info": {
            "description": "Bundled dataset",
            "version": "1.0",
        },
        "images": [],
        "annotations": [],
        "categories": [],
    }

    if manifest_path is not None:
        dataset["info"]["frame_manifest"] = str(manifest_path)
    if bundle_path:
        dataset["info"]["bundle_path"] = bundle_path
    if frames_without_labels:
        dataset["info"]["frames_without_labels"] = sorted(set(frames_without_labels))

    category_lookup: dict[str, int] = {}
    next_category_id = 1
    next_annotation_id = 1
    next_image_id = 1

    for record in ordered_records:
        width_value = record.get("width")
        height_value = record.get("height")
        if width_value is None or height_value is None:
            logging.warning(
                "Image dimensions missing for %s; defaulting to zero values",
                record["file_name"],
            )
        width_int = int(width_value) if width_value is not None else 0
        height_int = int(height_value) if height_value is not None else 0

        image_entry = {
            "id": next_image_id,
            "file_name": record["file_name"],
            "width": width_int,
            "height": height_int,
        }

        if record.get("label_file") is not None:
            image_entry["source_annotation"] = str(record["label_file"])
        if record.get("source_image_path") is not None:
            image_entry["source_image_path"] = record["source_image_path"]
        if record.get("frame_index") is not None:
            image_entry["frame_index"] = record["frame_index"]
        dataset["images"].append(image_entry)
        image_id = next_image_id
        next_image_id += 1

        for shape in record["data"].get("shapes", []):
            label = shape.get("label")
            shape_type = shape.get("shape_type", "polygon")
            points = shape.get("points", [])
            if not label or not points:
                logging.debug("Skipping shape without label or points in %s", record["label_file"])
                continue
            if shape_type not in SUPPORTED_SHAPES and len(points) < 3:
                logging.warning(
                    "Skipping unsupported shape type '%s' in %s", shape_type, record["label_file"]
                )
                continue

            polygon = to_polygon(points, shape_type)
            if len(polygon) < 3:
                logging.debug(
                    "Skipping shape with insufficient polygon vertices in %s", record["label_file"]
                )
                continue

            if label not in category_lookup:
                category_lookup[label] = next_category_id
                dataset["categories"].append(
                    {
                        "id": next_category_id,
                        "name": label,
                        "supercategory": "object",
                    }
                )
                next_category_id += 1

            category_id = category_lookup[label]
            area = polygon_area(polygon)
            bbox = bbox_from_polygon(polygon)
            segmentation = [flatten_polygon(polygon)]

            annotation_entry = {
                "id": next_annotation_id,
                "image_id": image_id,
                "category_id": category_id,
                "segmentation": segmentation,
                "bbox": bbox,
                "area": area,
                "iscrowd": 0,
                "source": str(record["label_file"]),
            }
            if record.get("frame_index") is not None:
                annotation_entry["frame_index"] = record["frame_index"]
            dataset["annotations"].append(annotation_entry)
            next_annotation_id += 1

    return dataset


def write_dataset(dataset: dict[str, Any], output_path: Path) -> None:
    ensure_output_path(output_path)
    with output_path.open("w", encoding="utf-8") as stream:
        json.dump(dataset, stream, indent=2)


def main(argv: list[str] | None = None) -> int:
    args = parse_args(argv)
    logging.basicConfig(level=getattr(logging, args.log_level))

    try:
        label_files = discover_label_files(args.labels)
    except FileNotFoundError as exc:
        logging.error(str(exc))
        return 1

    if not label_files:
        logging.error("No label files discovered in %s", args.labels)
        return 1

    logging.info("Discovered %d label files", len(label_files))

    manifest_data: dict[str, Any] | None = None
    manifest_reference: Path | str | None = None
    if args.skip_manifest:
        logging.info("Skipping manifest alignment as requested")
    else:
        manifest_candidate = args.manifest
        if manifest_candidate is None:
            if args.require_manifest:
                logging.error("Manifest required but no source was supplied.")
                return 1
            logging.info("Manifest source not provided; proceeding without alignment")
        elif str(manifest_candidate) == "-":
            payload = sys.stdin.read()
            if not payload.strip():
                if args.require_manifest:
                    logging.error("Manifest required but stdin was empty.")
                    return 1
                logging.info("No manifest content received on stdin; proceeding without alignment")
            else:
                try:
                    manifest_data = load_frame_manifest_from_string(payload)
                except ValueError as exc:
                    logging.error("Failed to parse manifest from stdin: %s", exc)
                    return 1
                manifest_reference = "inline"
                logging.info("Loaded frame manifest from stdin")
        elif manifest_candidate.exists():
            try:
                manifest_data = load_frame_manifest(manifest_candidate)
                manifest_reference = manifest_candidate
                logging.info("Loaded frame manifest from %s", manifest_candidate)
            except (OSError, ValueError) as exc:
                logging.error("Failed to load manifest %s: %s", manifest_candidate, exc)
                return 1
        else:
            if args.require_manifest:
                logging.error("Manifest required but not found at %s", manifest_candidate)
                return 1
            logging.info(
                "Manifest not found at %s; proceeding without alignment",
                manifest_candidate,
            )

    try:
        dataset = build_annotation_dataset(
            label_files,
            args.image_root,
            args.skip_missing_images,
            manifest_data,
            manifest_reference,
            args.require_manifest,
        )
    except (ValueError, FileNotFoundError) as exc:
        logging.error(str(exc))
        return 1

    write_dataset(dataset, args.output)
    logging.info("Unified annotations written to %s", args.output)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
